/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/policies/search": {
    /**
     * Retrieve/Search Policies
     *  
     * @description This operation provides you a list of available Policies qualifying the given keyword match.
     */
    get: operations["policySearch"];
  };
  "/application-rate-plans": {
    /**
     * Get all Application Rate Plans 
     * @description Retrieves all existing application rate plans.
     */
    get: operations["getApplicationRatePlans"];
    /**
     * Add an Application Rate Plan 
     * @description This operation can be used to add a new application level rate plan.
     */
    post: operations["addApplicationRatePlan"];
  };
  "/application-rate-plans/{planId}": {
    /**
     * Get an Application Rate Plan 
     * @description Retrieves an application rate plan.
     */
    get: operations["getApplicationRatePlanById"];
    /**
     * Update an Application Rate Plan 
     * @description Updates an existing application level rate plan. Upon a successful update, you will receive the updated application plan as the response.
     */
    put: operations["updateApplicationRatePlan"];
    /**
     * Delete an Application Rate Plan 
     * @description Deletes an application level rate plan.
     */
    delete: operations["removeApplicationRatePlan"];
  };
  "/business-plans": {
    /**
     * Get all Business Plans 
     * @description This operation can be used to retrieve all Business Plans.
     */
    get: operations["getAllBusinessPlans"];
    /**
     * Add a Business Plan 
     * @description This operation can be used to add a  Business Plan specifying the details of the plan in the payload.
     */
    post: operations["addBusinessPlan"];
  };
  "/business-plans/{planId}": {
    /**
     * Get a Business Plan 
     * @description This operation can be used to retrieves Business Plan by specifying the Id of the plan as a path parameter
     */
    get: operations["getBusinessPlanById"];
    /**
     * Update a Business Plan 
     * @description Updates an existing Business Plan.
     */
    put: operations["updateBusinessPlan"];
    /**
     * Delete a Business Plan 
     * @description This operation can be used to delete a business plan by specifying the Id of the plan as a path parameter.
     */
    delete: operations["removeBusinessPlan"];
  };
  "/throttling/policies/advanced": {
    /**
     * Get all Advanced Throttling Policies 
     * @description Retrieves all existing advanced throttling policies.
     */
    get: operations["getAllAdvancedPolicy"];
    /**
     * Add an Advanced Throttling Policy 
     * @description Add a new advanced throttling policy.
     */
    post: operations["addAdvancedPolicy"];
  };
  "/throttling/policies/advanced/{policyId}": {
    /**
     * Get an Advanced Throttling Policy 
     * @description Retrieves an advanced throttling policy.
     */
    get: operations["getAdvancedPolicyById"];
    /**
     * Update an Advanced Throttling Policy 
     * @description Updates an existing Advanced throttling policy.
     */
    put: operations["updateAdvancedPolicy"];
    /**
     * Delete an Advanced Throttling Policy 
     * @description Deletes an advanced throttling policy.
     */
    delete: operations["removeAdvancedPolicy"];
  };
  "/throttling/policies/export": {
    /**
     * Export a Throttling Policy 
     * @description This operation can be used to export the details of a particular Throttling Policy.
     */
    get: operations["exportThrottlingPolicy"];
  };
  "/throttling/policies/import": {
    /**
     * Import a Throttling Policy 
     * @description This operation can be used to import a Throttling Policy.
     */
    post: operations["importThrottlingPolicy"];
  };
  "/deny-policies": {
    /**
     * Get all Deny Policies 
     * @description Retrieves all existing deny policies.
     */
    get: operations["getAllDenyPolicies"];
    /**
     * Add a deny policy 
     * @description Adds a new deny policy
     */
    post: operations["addDenyPolicy"];
  };
  "/deny-policies/{policyId}": {
    /**
     * Get a Deny Policy 
     * @description Retrieves a Deny policy providing the policy Id
     */
    get: operations["getDenyPolicyById"];
    /**
     * Delete a Deny Policy 
     * @description Deletes an existing deny policy
     */
    delete: operations["removeDenyPolicy"];
    /**
     * Update a Deny Policy 
     * @description Update a deny policy by Id
     */
    patch: operations["updateDenyPolicy"];
  };
  "/applications": {
    /**
     * Retrieve/Search Applications
     *  
     * @description This operation can be used to retrieve list of applications owned by the given user, If no user
     * is provided, the applications owned by the user associated with the provided access token will be returned.
     */
    get: operations["getApplicationsByUser"];
  };
  "/applications/{applicationId}": {
    /**
     * Get the details of an Application
     *  
     * @description This operation can be used to get the details of an application by specifying its id.
     */
    get: operations["getApplicationById"];
    /**
     * Delete an Application
     *  
     * @description This operation can be used to delete an application by specifying its id.
     */
    delete: operations["removeApplication"];
  };
  "/applications/{applicationId}/change-owner": {
    /**
     * Change Application Owner 
     * @description This operation is used to change the owner of an Application.
     * In order to change the owner of an application, we need to pass the new application owner as a query parameter
     */
    post: operations["changeApplicationOwner"];
  };
  "/environments": {
    /**
     * Get all registered Environments 
     * @description Get all Registered Environments
     */
    get: operations["getEnvironments"];
    /**
     * Add an Environment 
     * @description Add a new gateway environment
     */
    post: operations["addEnvironment"];
  };
  "/environments/{environmentId}": {
    /**
     * Update an Environment 
     * @description Update a gateway Environment by environment Id
     */
    put: operations["updateEnvironment"];
    /**
     * Delete an Environment 
     * @description Delete a Environment by Environment Id
     */
    delete: operations["removeEnvironment"];
  };
  "/bot-detection-data": {
    /**
     * Get all Bot Detected Data
     *  
     * @description Get all bot detected data
     */
    get: operations["getBotDetectionData"];
  };
  "/monetization/publish-usage": {
    /**
     * Publish Usage Records 
     * @description Publish usage records of monetized APIs
     */
    post: operations["publishMonetizationRecords"];
  };
  "/monetization/publish-usage/status": {
    /**
     * Get the Status of Monetization Usage Publisher 
     * @description Get the status of monetization usage publisher
     */
    get: operations["getMonetizationUsagePublisherStatus"];
  };
  "/workflows": {
    /**
     * Retrieve All Pending Workflow Processes
     *  
     * @description This operation can be used to retrieve list of workflow pending processes.
     */
    get: operations["getAllPendingWorkflows"];
  };
  "/workflows/{externalWorkflowRef}": {
    /**
     * Get Pending Workflow Details by External Workflow Reference
     *  
     * @description Using this operation, you can retrieve complete details of a pending workflow request that either belongs to application creation, application subscription, application registration, api state change, user self sign up.. You need to provide the External_Workflow_Reference of the workflow Request to retrieve it.
     */
    get: operations["getWorkflowByExternalRef"];
  };
  "/workflows/update-workflow-status": {
    /**
     * Update Workflow Status 
     * @description This operation can be used to approve or reject a workflow task.
     */
    post: operations["updateWorkflowStatus"];
  };
  "/tenant-info/{username}": {
    /**
     * Get Tenant Id of User
     *  
     * @description This operation is to get tenant id of the provided user
     */
    get: operations["getTenantInfoByUsername"];
  };
  "/custom-urls/{tenantDomain}": {
    /**
     * Get Custom URL Info of a Tenant Domain
     *  
     * @description This operation is to get custom-url information of the provided tenant-domain
     */
    get: operations["getCustomUrlInfoByTenantDomain"];
  };
  "/api-categories": {
    /**
     * Get all API Categories 
     * @description Get all API categories
     */
    get: operations["getAllCategories"];
    /**
     * Add API Category 
     * @description Add a new API category
     */
    post: operations["addCategory"];
  };
  "/api-categories/{apiCategoryId}": {
    /**
     * Update an API Category 
     * @description Update an API Category by category Id
     */
    put: operations["updateCategory"];
    /**
     * Delete an API Category 
     * @description Delete an API Category by API Category Id
     */
    delete: operations["removeCategory"];
  };
  "/settings": {
    /**
     * Retrieve Admin Settings 
     * @description Retrieve admin settings
     */
    get: operations["getAdminSettings"];
  };
  "/system-scopes/{scopeName}": {
    /**
     * Retrieve Scopes for a Particular User 
     * @description This operation will return the scope list of particular user
     * In order to get it, we need to pass the userId as a query parameter
     */
    get: operations["systemScopesScopeNameGet"];
  };
  "/system-scopes": {
    /**
     * Get Role Scope Mappings
     *  
     * @description This operation is used to get the list of role scope mapping from tenant-conf for the APK admin dashboard
     */
    get: operations["systemScopesGet"];
    /**
     * Update Roles For Scope
     *  
     * @description This operation is used to update the roles for all scopes
     */
    put: operations["updateRolesForScope"];
  };
  "/system-scopes/role-aliases": {
    /**
     * Retrieve Role Alias Mappings 
     * @description This operation can be used to retrieve role alias mapping
     */
    get: operations["getRoleAliasMappings"];
    /**
     * Add a New Role Alias 
     * @description This operation can be used to add a new role alias mapping for system scope roles
     */
    put: operations["addRoleAliasMapping"];
  };
  "/roles/{roleId}": {
    /**
     * Check Whether Given Role Name already Exist 
     * @description Using this operation, user can check a given role name exists or not.
     */
    head: operations["validateSystemRole"];
  };
  "/tenant-theme": {
    /**
     * Export a DevPortal Tenant Theme 
     * @description This operation can be used to export a DevPortal tenant theme as a zip file.
     */
    get: operations["exportTenantTheme"];
    /**
     * Import a DevPortal Tenant Theme 
     * @description This operation can be used to import a DevPortal tenant theme.
     */
    put: operations["importTenantTheme"];
  };
  "/tenant-config": {
    /**
     * Export a tenant-Config. 
     * @description This operation can be used to export a tenant-config.json used in deployment.
     */
    get: operations["exportTenantConfig"];
    /**
     * Update a tenant-config. 
     * @description This operation can be used to update tenant-config.
     */
    put: operations["updateTenantConfig"];
  };
  "/tenant-config-schema": {
    /**
     * Export a tenant-Config-Schema. 
     * @description This operation can be used to export a tenant-config-schema.json used in deployment.
     */
    get: operations["exportTenantConfigSchema"];
  };
  "/key-managers": {
    /**
     * Get all Key managers 
     * @description Get all Key managers
     */
    get: operations["getAllKeyManagers"];
    /**
     * Add a new API Key Manager 
     * @description Add a new API Key Manager
     */
    post: operations["addNewKeyManager"];
  };
  "/key-managers/{keyManagerId}": {
    /**
     * Get a Key Manager Configuration 
     * @description Retrieve a single Key Manager Configuration. We should provide the Id of the KeyManager as a path parameter.
     */
    get: operations["getKeyManagerConfiguration"];
    /**
     * Update a Key Manager 
     * @description Update a Key Manager by keyManager ID
     */
    put: operations["updateKeyManager"];
    /**
     * Delete a Key Manager 
     * @description Delete a Key Manager by keyManager id
     */
    delete: operations["removeKeyManager"];
  };
  "/key-managers/discover": {
    /**
     * Retrieve Well-known information from Key Manager Well-known Endpoint 
     * @description Retrieve well-known information from key manager's well-known endpoint
     */
    post: operations["getWellKnownInfoKeyManager"];
  };
  "/organizations": {
    /**
     * Get all Organization 
     * @description Get all Organization
     */
    get: operations["getAllOrganization"];
    /**
     * Add Organization 
     * @description Add a new Organization
     */
    post: operations["addOrganization"];
  };
  "/organizations/{organizationId}": {
    /**
     * Get the details of an Organization
     *  
     * @description This operation can be used to get the details of an Organization by specifying its id.
     */
    get: operations["getOrganizationById"];
    /**
     * Update an Organization 
     * @description Update an Organization by organization Id
     */
    put: operations["updateOrganization"];
    /**
     * Delete an Organization 
     * @description Delete an Organization by API Organization Id
     */
    delete: operations["removeOrganization"];
  };
  "/organization-info": {
    /**
     * Authenticate Organization info
     *  
     * @description This operation can be used to authenticate Organization by specifying its claimValue.
     */
    get: operations["getOrganizationByClaimValue"];
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    /** Error object returned with 4XX HTTP status */
    Error: {
      /**
       * Format: int64 
       * @description Error code
       */
      code: number;
      /** @description Error message. */
      message: string;
      /** @description A detail description about the error message. */
      description?: string;
      /** @description Preferably an url with more details about the error. */
      moreInfo?: string;
      /**
       * @description If there are more than one error list them out.
       * For example, list out validation errors by each field.
       */
      error?: (components["schemas"]["ErrorListItem"])[];
    };
    /** Description of individual errors that may have occurred during a request. */
    ErrorListItem: {
      /** @description Error code */
      code: string;
      /** @description Description about individual errors occurred */
      message: string;
    };
    /** Policy List */
    PolicyList: {
      /**
       * @description Number of Policies returned.
       *  
       * @example 1
       */
      count?: number;
      list?: (components["schemas"]["Policy"])[];
      pagination?: components["schemas"]["Pagination"];
    };
    /** Policy List */
    PolicyDetailsList: {
      /**
       * @description Number of Throttling Policies returned.
       *  
       * @example 1
       */
      count?: number;
      list?: (components["schemas"]["PolicyDetails"])[];
    };
    /** Generic Policy */
    PolicyDetails: {
      /**
       * @description Id of policy 
       * @example 3
       */
      policyId?: number;
      /**
       * @description UUId of policy 
       * @example 0c6439fd-9b16-3c2e-be6e-1086e0b9aa93
       */
      uuid?: string;
      /**
       * @description Name of policy 
       * @example 30PerMin
       */
      policyName: string;
      /**
       * @description Display name of the policy 
       * @example 30PerMin
       */
      displayName?: string;
      /**
       * @description Description of the policy 
       * @example Allows 30 request per minute
       */
      description?: string;
      /**
       * @description Indicates whether the policy is deployed successfully or not. 
       * @default false
       */
      isDeployed?: boolean;
      /** @description Indicates the type of throttle policy */
      type?: string;
    };
    /** Generic Throttling Policy */
    Policy: {
      /**
       * @description Id of plan 
       * @example 0c6439fd-9b16-3c2e-be6e-1086e0b9aa93
       */
      planId?: string;
      /**
       * @description Name of plan 
       * @example 30PerMin
       */
      planName: string;
      /**
       * @description Display name of the policy 
       * @example 30PerMin
       */
      displayName?: string;
      /**
       * @description Description of the policy 
       * @example Allows 30 request per minute
       */
      description?: string;
      /**
       * @description Indicates whether the policy is deployed successfully or not. 
       * @default false
       */
      isDeployed?: boolean;
      /** @description Indicates the type of throttle policy */
      type?: string;
    };
    /** Export Policy */
    ExportPolicy: {
      type?: string;
      subtype?: string;
      version?: string;
      data?: Record<string, never>;
    };
    /** Advanced Throttling Policy */
    AdvancedThrottlePolicyInfo: {
      type: "AdvancedThrottlePolicyInfo";
    } & Omit<components["schemas"]["Policy"], "type"> & {
      defaultLimit?: components["schemas"]["ThrottleLimit"];
    };
    /** Advanced Throttling Policy */
    AdvancedThrottlePolicy: {
      type: "AdvancedThrottlePolicy";
    } & Omit<components["schemas"]["Policy"], "type"> & {
      defaultLimit: components["schemas"]["ThrottleLimit"];
      /** @description Group of conditions which allow adding different parameter conditions to the throttling limit. */
      conditionalGroups?: (components["schemas"]["ConditionalGroup"])[];
    };
    /** Advanced Throttling Policy List */
    AdvancedThrottlePolicyList: {
      /**
       * @description Number of Advanced Throttling Policies returned.
       *  
       * @example 1
       */
      count?: number;
      list?: (components["schemas"]["AdvancedThrottlePolicyInfo"])[];
    };
    /** Application Throttling Policy */
    ApplicationRatePlan: {
      type: "ApplicationRatePlan";
    } & Omit<components["schemas"]["Policy"], "type"> & {
      defaultLimit: components["schemas"]["ThrottleLimit"];
    };
    /** Application level Rate Plan List */
    ApplicationRatePlanList: {
      /**
       * @description Number of Application Rate Plans returned.
       *  
       * @example 1
       */
      count?: number;
      list?: (components["schemas"]["ApplicationRatePlan"])[];
    };
    /** Business Plan */
    BusinessPlan: {
      type: "BusinessPlan";
    } & Omit<components["schemas"]["Policy"], "type"> & components["schemas"]["GraphQLQuery"] & {
      defaultLimit: components["schemas"]["ThrottleLimit"];
      /**
       * @description Burst control request count 
       * @example 10
       */
      rateLimitCount?: number;
      /**
       * @description Burst control time unit 
       * @example min
       */
      rateLimitTimeUnit?: string;
      /**
       * @description Number of subscriptions allowed 
       * @example 10
       */
      subscriberCount?: number;
      /**
       * @description Custom attributes added to the Subscription Throttling Policy
       *  
       * @example []
       */
      customAttributes?: (components["schemas"]["CustomAttribute"])[];
      permissions?: components["schemas"]["BusinessPlanPermission"];
    };
    /** Business Plan Permission */
    BusinessPlanPermission: {
      /**
       * @example deny 
       * @enum {string}
       */
      permissionType: "ALLOW" | "DENY";
      /**
       * @example [
       *   "Internal/everyone"
       * ]
       */
      roles: (string)[];
    };
    /** GraphQL Query */
    GraphQLQuery: {
      /**
       * @description Maximum Complexity of the GraphQL query 
       * @example 400
       */
      graphQLMaxComplexity?: number;
      /**
       * @description Maximum Depth of the GraphQL query 
       * @example 10
       */
      graphQLMaxDepth?: number;
    };
    /** Business Plan List */
    BusinessPlanList: {
      /**
       * @description Number of Business Plans returned.
       *  
       * @example 1
       */
      count?: number;
      list?: (components["schemas"]["BusinessPlan"])[];
    };
    /** Conditional Groups for Throttling */
    ConditionalGroup: {
      /** @description Description of the Conditional Group */
      description?: string;
      /**
       * @description Individual throttling conditions. They can be defined as either HeaderCondition, IPCondition, JWTClaimsCondition, QueryParameterCondition
       * Please see schemas of each of those throttling condition in Definitions section.
       *  
       * @example [
       *   {
       *     "type": "HEADERCONDITION",
       *     "invertCondition": false,
       *     "headerCondition":
       *     {
       *       "headerName": "Host",
       *       "headerValue": "10.100.7.77"
       *     }
       *   },
       *   {
       *     "type": "IPCONDITION",
       *     "invertCondition": false,
       *     "ipCondition":
       *     {
       *       "ipConditionType": "IPSPECIFIC",
       *       "specificIP": "10.100.1.22",
       *       "startingIP": null,
       *       "endingIP": null
       *     }
       *   },
       *   {
       *     "type": "QUERYPARAMETERCONDITION",
       *     "invertCondition": false,
       *     "queryParameterCondition":
       *     {
       *       "parameterName": "name",
       *       "parameterValue": "admin"
       *     }
       *   },
       *   {
       *     "type": "JWTCLAIMSCONDITION",
       *     "invertCondition": true,
       *     "jwtClaimsCondition":
       *     {
       *       "claimUrl": "claimUrl0",
       *       "attribute": "claimAttr0"
       *     }
       *   }
       * ]
       */
      conditions: (components["schemas"]["ThrottleCondition"])[];
      limit: components["schemas"]["ThrottleLimit"];
    };
    /**
     * Throttling Conditions 
     * @description Conditions used for Throttling
     */
    ThrottleCondition: {
      /**
       * @description Type of the throttling condition. Allowed values are "HEADERCONDITION", "IPCONDITION", "JWTCLAIMSCONDITION"
       * and "QUERYPARAMETERCONDITION".
       *  
       * @enum {string}
       */
      type: "HEADERCONDITION" | "IPCONDITION" | "JWTCLAIMSCONDITION" | "QUERYPARAMETERCONDITION";
      /**
       * @description Specifies whether inversion of the condition to be matched against the request.
       * 
       * **Note:** When you add conditional groups for advanced throttling policies, this parameter should have the
       * same value ('true' or 'false') for the same type of conditional group.
       *  
       * @default false
       */
      invertCondition?: boolean;
      headerCondition?: components["schemas"]["HeaderCondition"];
      ipCondition?: components["schemas"]["IPCondition"];
      jwtClaimsCondition?: components["schemas"]["JWTClaimsCondition"];
      queryParameterCondition?: components["schemas"]["QueryParameterCondition"];
    };
    /** HTTP Header based throttling condition */
    HeaderCondition: {
      /** @description Name of the header */
      headerName: string;
      /** @description Value of the header */
      headerValue: string;
    };
    /** IP based throttling condition */
    IPCondition: {
      /**
       * @description Type of the IP condition. Allowed values are "IPRANGE" and "IPSPECIFIC" 
       * @enum {string}
       */
      ipConditionType?: "IPRANGE" | "IPSPECIFIC";
      /** @description Specific IP when "IPSPECIFIC" is used as the ipConditionType */
      specificIP?: string;
      /** @description Staring IP when "IPRANGE" is used as the ipConditionType */
      startingIP?: string;
      /** @description Ending IP when "IPRANGE" is used as the ipConditionType */
      endingIP?: string;
    };
    /** JWT claim attribute based throttling condition */
    JWTClaimsCondition: {
      /** @description JWT claim URL */
      claimUrl: string;
      /** @description Attribute to be matched */
      attribute: string;
    };
    /** Query parameter based throttling condition */
    QueryParameterCondition: {
      /** @description Name of the query parameter */
      parameterName: string;
      /** @description Value of the query parameter to be matched */
      parameterValue: string;
    };
    /** Throttle Limit Base */
    ThrottleLimitBase: {
      /**
       * @description Unit of the time. Allowed values are "sec", "min", "hour", "day" 
       * @example min
       */
      timeUnit: string;
      /**
       * @description Time limit that the throttling limit applies. 
       * @example 10
       */
      unitTime: number;
    };
    /** Throttle Limit */
    ThrottleLimit: {
      /**
       * @description Type of the throttling limit. Allowed values are "REQUESTCOUNTLIMIT" and "BANDWIDTHLIMIT".
       * Please see schemas of "RequestCountLimit" and "BandwidthLimit" throttling limit types in
       * Definitions section.
       *  
       * @example REQUESTCOUNTLIMIT 
       * @enum {string}
       */
      type: "REQUESTCOUNTLIMIT" | "BANDWIDTHLIMIT" | "EVENTCOUNTLIMIT";
      requestCount?: components["schemas"]["RequestCountLimit"];
      bandwidth?: components["schemas"]["BandwidthLimit"];
      eventCount?: components["schemas"]["EventCountLimit"];
    };
    /** API monetization details object */
    MonetizationInfo: {
      /**
       * @description Flag to indicate the monetization plan 
       * @example FixedRate 
       * @enum {string}
       */
      monetizationPlan?: "FIXEDRATE" | "DYNAMICRATE";
      /** @description Map of custom properties related to each monetization plan */
      properties: {
        [key: string]: string | undefined;
      };
    };
    /** Bandwidth Limit object */
    BandwidthLimit: components["schemas"]["ThrottleLimitBase"] & {
      /**
       * Format: int64 
       * @description Amount of data allowed to be transferred 
       * @example 1000
       */
      dataAmount: number;
      /**
       * @description Unit of data allowed to be transferred. Allowed values are "KB", "MB" and "GB" 
       * @example KB
       */
      dataUnit: string;
    };
    /** Request Count Limit object */
    RequestCountLimit: components["schemas"]["ThrottleLimitBase"] & {
      /**
       * Format: int64 
       * @description Maximum number of requests allowed 
       * @example 30
       */
      requestCount: number;
    };
    /** Event Count Limit object */
    EventCountLimit: components["schemas"]["ThrottleLimitBase"] & {
      /**
       * Format: int64 
       * @description Maximum number of events allowed 
       * @example 3000
       */
      eventCount: number;
    };
    /**
     * Blocking Conditions 
     * @description Blocking Conditions
     */
    BlockingCondition: {
      /**
       * @description Id of the blocking condition 
       * @example b513eb68-69e8-4c32-92cf-852c101363cf
       */
      policyId?: string;
      /**
       * @description Type of the blocking condition 
       * @example IP 
       * @enum {string}
       */
      conditionType: "API" | "APPLICATION" | "IP" | "IPRANGE" | "USER";
      /**
       * @description Value of the blocking condition 
       * @example {
       *   "fixedIp": "192.168.1.1",
       *   "invert": false
       * }
       */
      conditionValue: Record<string, never>;
      /**
       * @description Status of the blocking condition 
       * @example true
       */
      conditionStatus?: boolean;
    };
    /** Blocking Conditions List */
    BlockingConditionList: {
      /**
       * @description Number of Blocking Conditions returned.
       *  
       * @example 1
       */
      count?: number;
      list?: (components["schemas"]["BlockingCondition"])[];
    };
    /**
     * Blocking Conditions Status 
     * @description Blocking Conditions Status
     */
    BlockingConditionStatus: {
      /**
       * @description Id of the blocking condition 
       * @example b513eb68-69e8-4c32-92cf-852c101363cf
       */
      policyId?: string;
      /**
       * @description Status of the blocking condition 
       * @example true
       */
      conditionStatus: boolean;
    };
    /** Name-Value pair */
    CustomAttribute: {
      /**
       * @description Name of the custom attribute 
       * @example customAttr1
       */
      name: string;
      /**
       * @description Value of the custom attribute 
       * @example value1
       */
      value: string;
    };
    /** Application List */
    ApplicationList: {
      /**
       * @description Number of applications returned.
       *  
       * @example 1
       */
      count?: number;
      list?: (components["schemas"]["ApplicationInfo"])[];
      pagination?: components["schemas"]["Pagination"];
    };
    /** Application info object with basic application details */
    ApplicationInfo: {
      /** @example 01234567-0123-0123-0123-012345678901 */
      applicationId?: string;
      /** @example CalculatorApp */
      name?: string;
      /** @example admin */
      owner?: string;
      /** @example APPROVED */
      status?: string;
      /** @example */
      groupId?: string;
    };
    /** Application object with all the application details */
    Application: {
      /** @example 01234567-0123-0123-0123-012345678901 */
      applicationId?: string;
      /** @example CalculatorApp */
      name?: string;
      /** @example Unlimited */
      throttlingPolicy?: string;
      /** @example Sample calculator application */
      description?: string;
      /**
       * @description Type of the access token generated for this application.
       * **OAUTH:** A UUID based access token which is issued by default.
       * **JWT:** A self-contained, signed JWT based access token. **Note:** This can be only used in Microgateway environments.
       *  
       * @default JWT 
       * @example JWT 
       * @enum {string}
       */
      tokenType?: "OAUTH" | "JWT";
      /**
       * @default  
       * @example APPROVED
       */
      status?: string;
      /** @example */
      groups?: (string)[];
      subscriptionCount?: number;
      /** @example External Reference ID, Billing Tier */
      attributes?: {
        [key: string]: string | undefined;
      };
      subscriptionScopes?: (components["schemas"]["ScopeInfo"])[];
      /**
       * @description Application created user
       *  
       * @example admin
       */
      owner?: string;
    };
    /** API Scope info object with scope details */
    ScopeInfo: {
      /** @example admin_scope */
      key?: string;
      /** @example admin scope */
      name?: string;
      /**
       * @description Allowed roles for the scope 
       * @example [
       *   "manager",
       *   "developer"
       * ]
       */
      roles?: (string)[];
      /** @description Description of the scope */
      description?: string;
    };
    /** Environment */
    Environment: {
      /** @example ece92bdc-e1e6-325c-b6f4-656208a041e9 */
      id?: string;
      /** @example us-region */
      name: string;
      /** @example US Region */
      displayName?: string;
      /** @example wso2 */
      provider?: string;
      /** @example Gateway environment in US Region */
      description?: string;
      /** @example false */
      isReadOnly?: boolean;
      vhosts: (components["schemas"]["VHost"])[];
      endpointURIs?: (components["schemas"]["GatewayEnvironmentProtocolURI"])[];
      additionalProperties?: (components["schemas"]["AdditionalProperty"])[];
    };
    /** Environment List */
    EnvironmentList: {
      /**
       * @description Number of Environments returned.
       *  
       * @example 1
       */
      count?: number;
      list?: (components["schemas"]["Environment"])[];
    };
    /** Virtual Host */
    VHost: {
      /** @example mg.wso2.com */
      host: string;
      /** @example pets */
      httpContext?: string;
      /** @example 80 */
      httpPort?: number;
      /** @example 443 */
      httpsPort?: number;
      /** @example 9099 */
      wsPort?: number;
      /** @example 8099 */
      wssPort?: number;
    };
    /** Additional Gateway Properties */
    AdditionalProperty: {
      /** @example Organization */
      key?: string;
      /** @example wso2 */
      value?: string;
    };
    /** Gateway Environment protocols and URIs */
    GatewayEnvironmentProtocolURI: {
      /** @example default */
      protocol: string;
      /** @example default */
      endpointURI: string;
    };
    /** Usage publish status */
    PublishStatus: {
      /**
       * @description Status of the usage publish request 
       * @example successful
       */
      status?: string;
      /**
       * @description detailed message of the status 
       * @example Records published successfully
       */
      message?: string;
    };
    /** Usage publish status */
    MonetizationUsagePublishInfo: {
      /**
       * @description State of usage publish job 
       * @example RUNNING
       */
      state?: string;
      /**
       * @description Status of usage publish job 
       * @example SUCCESSFULL
       */
      status?: string;
      /**
       * @description Timestamp of the started time of the Job 
       * @example 1599196134000
       */
      startedTime?: string;
      /**
       * @description Timestamp of the last published time 
       * @example 1599196134000
       */
      lastPublsihedTime?: string;
    };
    /** workflow */
    Workflow: {
      /**
       * @description This attribute declares whether this workflow task is approved or rejected.
       *  
       * @example APPROVED 
       * @enum {string}
       */
      status: "APPROVED" | "REJECTED";
      /**
       * @description Custom attributes to complete the workflow task
       *  
       * @example {}
       */
      attributes?: {
        [key: string]: string | undefined;
      };
      /** @example Approve workflow request. */
      description?: string;
    };
    /**
     * Tenant information 
     * @description The tenant information of the user
     */
    TenantInfo: {
      /** @example john */
      username?: string;
      /** @example carbon.super */
      tenantDomain?: string;
      /** @example -1234 */
      tenantId?: number;
    };
    /**
     * Custom url information 
     * @description The custom url information of the tenant domain
     */
    CustomUrlInfo: {
      /** @example carbon.super */
      tenantDomain?: string;
      /** @example john@foo.com */
      tenantAdminUsername?: string;
      /** @example true */
      enabled?: boolean;
      devPortal?: {
        /** @example http://example.com */
        url?: string;
      };
    };
    /** Organization */
    Organization: {
      /** @example 01234567-0123-0123-0123-012345678901 */
      id?: string;
      /** @example Finance */
      name: string;
      /** @example Finance */
      displayName: string;
      /** @example 01234567-0123-0123-0123 */
      organizationClaimValue?: string;
      /** @default true */
      enabled?: boolean;
      /**
       * @default [
       *   "*"
       * ]
       */
      serviceNamespaces?: (string)[];
      production?: (string)[];
      sandbox?: (string)[];
    };
    /** Organization List */
    OrganizationList: {
      /**
       * @description Number of Organization returned.
       *  
       * @example 1
       */
      count?: number;
      list?: (components["schemas"]["Organization"])[];
    };
    /** API Category */
    APICategory: {
      /** @example 01234567-0123-0123-0123-012345678901 */
      id?: string;
      /** @example Finance */
      name: string;
      /** @example Finance related APIs */
      description?: string;
      /** @example 1 */
      numberOfAPIs?: number;
    };
    /** API Category List */
    APICategoryList: {
      /**
       * @description Number of API categories returned.
       *  
       * @example 1
       */
      count?: number;
      list?: (components["schemas"]["APICategory"])[];
    };
    /** File Information including meta data */
    FileInfo: {
      /**
       * @description relative location of the file (excluding the base context and host of the Admin API) 
       * @example api-categories/01234567-0123-0123-0123-012345678901/thumbnail
       */
      relativePath?: string;
      /**
       * @description media-type of the file 
       * @example image/jpeg
       */
      mediaType?: string;
    };
    /** Settings */
    Settings: {
      scopes?: (string)[];
      keyManagerConfiguration?: ({
          /** @example default */
          type?: string;
          /** @example default */
          displayName?: string;
          /** @example azp */
          defaultConsumerKeyClaim?: string;
          /** @example scope */
          defaultScopesClaim?: string;
          configurations?: (components["schemas"]["KeyManagerConfiguration"])[];
          endpointConfigurations?: (components["schemas"]["KeyManagerConfiguration"])[];
        })[];
      /**
       * @description To determine whether analytics is enabled or not 
       * @example false
       */
      analyticsEnabled?: boolean;
    };
    /** Scope Role Mapping List */
    ScopeList: {
      /**
       * @description Number of scopes available for tenant.
       *  
       * @example 60
       */
      count?: number;
      list?: (components["schemas"]["Scope"])[];
    };
    /** Scope Role */
    Scope: {
      /**
       * @description Portal name.
       *  
       * @example publisher
       */
      tag?: string;
      /**
       * @description Scope name.
       *  
       * @example apk:api_publish
       */
      name?: string;
      /**
       * @description About scope.
       *  
       * @example Publish API
       */
      description?: string;
      /**
       * @description Roles for the particular scope.
       *  
       * @example [
       *   "admin",
       *   "Internal/publisher"
       * ]
       */
      roles?: (string)[];
    };
    /** Key Manager Well-Known Response. */
    KeyManagerWellKnownResponse: {
      /**
       * @default false 
       * @example true
       */
      valid?: boolean;
      value?: components["schemas"]["KeyManager"];
    };
    /** Key Manager */
    KeyManager: {
      /** @example 01234567-0123-0123-0123-012345678901 */
      id?: string;
      /** @example WSO2 Identity Server */
      name: string;
      /**
       * @description display name of Key Manager to  show in UI
       *  
       * @example WSO2 Identity Server
       */
      displayName?: string;
      /** @example WSO2-IS */
      type: string;
      /** @example This is a key manager for Developers */
      description?: string;
      /**
       * @description Well-Known Endpoint of Identity Provider.
       *  
       * @example
       */
      wellKnownEndpoint?: string;
      /**
       * @deprecated 
       * @example https://localhost:9444/oauth2/introspect
       */
      introspectionEndpoint?: string;
      /**
       * @deprecated 
       * @example https://localhost:9444/keymanager-operations/dcr/register
       */
      clientRegistrationEndpoint?: string;
      /**
       * @deprecated 
       * @example https://localhost:9444/oauth2/token
       */
      tokenEndpoint?: string;
      /**
       * @deprecated 
       * @example https://localhost:9444/oauth2/token
       */
      displayTokenEndpoint?: string;
      /**
       * @deprecated 
       * @example https://localhost:9444/oauth2/revoke
       */
      revokeEndpoint?: string;
      /**
       * @deprecated 
       * @example https://localhost:9444/oauth2/revoke
       */
      displayRevokeEndpoint?: string;
      /**
       * @deprecated 
       * @example https://localhost:9444/oauth2/userinfo?schema=openid
       */
      userInfoEndpoint?: string;
      /**
       * @deprecated 
       * @example https://localhost:9444/oauth2/authorize
       */
      authorizeEndpoint?: string;
      endpoints?: (components["schemas"]["KeyManagerEndpoint"])[];
      certificates?: {
        /** @enum {string} */
        type?: "JWKS" | "PEM";
        value?: string;
      };
      /** @example https://localhost:9444/services */
      issuer?: string;
      /**
       * @description The alias of Identity Provider.
       * If the tokenType is EXCHANGED, the alias value should be inclusive in the audience values of the JWT token
       *  
       * @example https://localhost:9443/oauth2/token
       */
      alias?: string;
      /**
       * @deprecated 
       * @example https://wso2is.com:9444/api/identity/oauth2/v1.0/scopes
       */
      scopeManagementEndpoint?: string;
      availableGrantTypes?: (string)[];
      /** @example true */
      enableTokenGeneration?: boolean;
      /**
       * @default false 
       * @example false
       */
      enableTokenEncryption?: boolean;
      /**
       * @default false 
       * @example false
       */
      enableTokenHashing?: boolean;
      /**
       * @default false 
       * @example false
       */
      enableMapOAuthConsumerApps?: boolean;
      /**
       * @default false 
       * @example false
       */
      enableOAuthAppCreation?: boolean;
      /**
       * @default true 
       * @example true
       */
      enableSelfValidationJWT?: boolean;
      claimMapping?: (components["schemas"]["ClaimMappingEntry"])[];
      /** @example azp */
      consumerKeyClaim?: string;
      /** @example scp */
      scopesClaim?: string;
      tokenValidation?: (components["schemas"]["TokenValidation"])[];
      /** @example true */
      enabled?: boolean;
      /**
       * @example {
       *   "self_validate_jwt": true,
       *   "Username": "admin",
       *   "Password": "admin"
       * }
       */
      additionalProperties?: Record<string, never>;
      /**
       * @description The type of the tokens to be used (exchanged or without exchanged). Accepted values are EXCHANGED, DIRECT and BOTH. 
       * @default DIRECT 
       * @example EXCHANGED 
       * @enum {string}
       */
      tokenType?: "EXCHANGED" | "DIRECT" | "BOTH";
    };
    /** Key Manager Endpoint. */
    KeyManagerEndpoint: {
      /** @example token_endpoint */
      name: string;
      /** @example https://localhost:9443/oauth2/token */
      value: string;
    };
    /** Key Manager Info */
    KeyManagerInfo: {
      /** @example 01234567-0123-0123-0123-012345678901 */
      id?: string;
      /** @example WSO2 IS */
      name: string;
      /** @example IS */
      type: string;
      /** @example This is a key manager for Developers */
      description?: string;
      /** @example true */
      enabled?: boolean;
      /**
       * @description The type of the tokens to be used (exchanged or without exchanged). Accepted values are EXCHANGED, DIRECT and BOTH. 
       * @default DIRECT 
       * @example EXCHANGED 
       * @enum {string}
       */
      tokenType?: "EXCHANGED" | "DIRECT" | "BOTH";
    };
    /** Key Manager Configuration */
    KeyManagerConfiguration: {
      /** @example consumer_key */
      name?: string;
      /** @example Consumer Key */
      label?: string;
      /** @example select */
      type?: string;
      /** @example true */
      required?: boolean;
      /** @example true */
      mask?: boolean;
      /** @example true */
      multiple?: boolean;
      /** @example Enter username to connect to key manager */
      tooltip?: string;
      /** @example admin */
      default?: Record<string, never>;
      values?: (Record<string, never>)[];
    };
    /** Key Manager List */
    KeyManagerList: {
      /**
       * @description Number of Key managers returned.
       *  
       * @example 1
       */
      count?: number;
      list?: (components["schemas"]["KeyManagerInfo"])[];
    };
    /** Claim Mapping Configuration */
    ClaimMappingEntry: {
      /** @example http://idp.org/username */
      remoteClaim?: string;
      /** @example http://wso2.org/username */
      localClaim?: string;
    };
    /** Token handling Configuration */
    TokenValidation: {
      id?: number;
      /**
       * @default true 
       * @example false
       */
      enable?: boolean;
      /** @enum {string} */
      type?: "REFERENCE" | "JWT" | "CUSTOM";
      value?: Record<string, never>;
    };
    /** Settings */
    ScopeSettings: {
      /** @example apk:subscribe */
      name?: string;
    };
    /** WorkflowList */
    WorkflowList: {
      /**
       * @description Number of workflow processes returned.
       *  
       * @example 1
       */
      count?: number;
      /**
       * @description Link to the next subset of resources qualified.
       * Empty if no more resources are to be returned.
       *  
       * @example /workflows?limit=1&offset=2&user=
       */
      next?: string;
      /**
       * @description Link to the previous subset of resources qualified.
       * Empty if current subset is the first subset returned.
       *  
       * @example /workflows?limit=1&offset=0&user=
       */
      previous?: string;
      list?: (components["schemas"]["WorkflowInfo"])[];
    };
    /** Workflow info object with basic workflow details */
    WorkflowInfo: {
      /**
       * @description Type of the Workflow Request. It shows which type of request is it.
       *  
       * @example APPLICATION_CREATION 
       * @enum {string}
       */
      workflowType?: "APPLICATION_CREATION" | "SUBSCRIPTION_CREATION" | "USER_SIGNUP" | "APPLICATION_REGISTRATION_PRODUCTION" | "APPLICATION_REGISTRATION_SANDBOX" | "APPLICATION_DELETION" | "API_STATE" | "API_PRODUCT_STATE" | "SUBSCRIPTION_DELETION" | "SUBSCRIPTION_UPDATE";
      /**
       * @description Show the Status of the the workflow request whether it is approved or created.
       *  
       * @example APPROVED 
       * @enum {string}
       */
      workflowStatus?: "APPROVED" | "CREATED";
      /**
       * @description Time of the the workflow request created.
       *  
       * @example "2020-02-10T10:10:19.704Z"
       */
      createdTime?: string;
      /**
       * @description Time of the the workflow request updated.
       *  
       * @example "2020-02-10T10:10:19.704Z"
       */
      updatedTime?: string;
      /**
       * @description Workflow external reference is used to identify the workflow requests uniquely.
       *  
       * @example 5871244b-d6f3-466e-8995-8accd1e64303
       */
      referenceId?: string;
      properties?: Record<string, never>;
      /**
       * @description description is a message with basic details about the workflow request.
       *  
       * @example Approve application [APP1] creation request from application creator - admin with throttling tier - 10MinPer
       */
      description?: string;
    };
    /** workflow Response */
    WorkflowResponse: {
      /**
       * @description This attribute declares whether this workflow task is approved or rejected.
       *  
       * @example APPROVED 
       * @enum {string}
       */
      workflowStatus: "CREATED" | "APPROVED" | "REJECTED" | "REGISTERED";
      /** @description Attributes that returned after the workflow execution */
      jsonPayload?: string;
    };
    /** Bot Detection Data List */
    BotDetectionDataList: {
      /**
       * @description Number of Bot Detection Data returned.
       *  
       * @example 1
       */
      count?: number;
      list?: (components["schemas"]["BotDetectionData"])[];
    };
    /** Bot Detection Data */
    BotDetectionData: {
      /**
       * Format: int64 
       * @description The time of detection 
       * @example 1591734138413
       */
      recordedTime?: number;
      /**
       * @description The message ID 
       * @example urn:uuid:1ed6d2de-29df-4fed-a96a-46d2329dce65
       */
      messageID?: string;
      /**
       * @description The api method 
       * @example GET
       */
      apiMethod?: string;
      /**
       * @description The header set 
       * @example [Accept=*\/*, Host=localhost:8243, User-Agent=curl/7.58.0]
       */
      headerSet?: string;
      /**
       * @description The content of the message body 
       * @example <soapenv:Body xmlns:soapenv=\"http://www.w3.org/2003/05/soap-envelope\"/>
       */
      messageBody?: string;
      /**
       * @description The IP of the client 
       * @example 127.0.0.1
       */
      clientIp?: string;
    };
    /** Role alias list */
    RoleAliasList: {
      /**
       * @description The number of role aliases 
       * @example 1
       */
      count?: number;
      list?: (components["schemas"]["RoleAlias"])[];
    };
    /** Role alias */
    RoleAlias: {
      /**
       * @description The original role 
       * @example Internal/subscriber
       */
      role?: string;
      /**
       * @description The role mapping for role alias 
       * @example [
       *   "Subscriber",
       *   "Internal/subscriber"
       * ]
       */
      aliases?: (string)[];
    };
    /** Pagination */
    Pagination: {
      /** @example 0 */
      offset?: number;
      /** @example 1 */
      limit?: number;
      /** @example 10 */
      total?: number;
      /**
       * @description Link to the next subset of resources qualified.
       * Empty if no more resources are to be returned.
       * example: ""
       */
      next?: string;
      /**
       * @description Link to the previous subset of resources qualified.
       * Empty if current subset is the first subset returned.
       * example: ""
       */
      previous?: string;
    };
  };
  responses: {
    /** @description Bad Request. Invalid request or validation error. */
    BadRequest: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Conflict. Specified resource already exists. */
    Conflict: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Forbidden. The request must be conditional but no condition has been specified. */
    Forbidden: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Internal Server Error. */
    InternalServerError: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Not Acceptable. The requested media type is not supported. */
    NotAcceptable: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Not Found. The specified resource does not exist. */
    NotFound: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Payload Too Large. Request entity is larger than limits defined by server. */
    PayloadTooLarge: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Precondition Failed. The request has not been performed because one of the preconditions is not met. */
    PreconditionFailed: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Unauthorized. The user is not authorized. */
    Unauthorized: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
    /** @description Unsupported Media Type. The entity of the request was not in a supported format. */
    UnsupportedMediaType: {
      content: {
        "application/json": components["schemas"]["Error"];
      };
    };
  };
  parameters: {
    /**
     * @description Validator for conditional requests; based on the ETag of the formerly retrieved
     * variant of the resource.
     */
    "If-None-Match": string;
    /**
     * @description For cross-tenant invocations, this is used to specify the tenant domain, where the resource need to be
     *   retirieved from.
     */
    requestedTenant: string;
    /** @description Criteria for sorting. */
    sortBy: "apiName" | "version" | "createdTime" | "status";
    /** @description Order of sorting(ascending/descending). */
    sortOrder: "asc" | "desc";
    /** @description username of the new application owner */
    username: string;
    /** @description Base64 URL encoded value of the scope name to be validated */
    scopeName: string;
    /** @description Environment UUID (or Environment name defined in config) */
    environmentId: string;
    /** @description Policy UUID */
    policyId: string;
    /** @description Policy UUID */
    planId: string;
    /** @description Custom rule UUID */
    ruleId: string;
    /** @description Application UUID */
    applicationId: string;
    /** @description Media types acceptable for the response. Default is application/json. */
    Accept: string;
    /** @description Media type of the entity in the body. Default is application/json. */
    "Content-Type": string;
    /** @description Maximum size of resource array to return. */
    limit: number;
    /** @description Starting point within the complete list of items qualified. */
    offset: number;
    /** @description username of the application creator */
    user: string;
    /** @description Workflow reference id */
    "workflowReferenceId-Q": string;
    /** @description API Category UUID */
    apiCategoryId: string;
    /** @description Organization UUID */
    organizationId: string;
    /** @description Key Manager UUID */
    keyManagerId: string;
    /**
     * @description The Base 64 URL encoded role name with domain. If the given role is in PRIMARY user-store, role ID should be
     * derived as Base64URLEncode(role-name). If the given role is in secondary user-store, role ID should be
     * derived as Base64URLEncode({user-store-name}/{role-name}).
     */
    roleId: string;
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type external = Record<string, never>;

export interface operations {

  policySearch: {
    /**
     * Retrieve/Search Policies
     *  
     * @description This operation provides you a list of available Policies qualifying the given keyword match.
     */
    parameters?: {
        /**
         * @description **Search**.
         * You can search by providing a keyword. Allowed to search by type and name only.
         */
      query?: {
        query?: string;
      };
    };
    responses: {
      /**
       * @description OK.
       * List of qualifying Policies is returned.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["PolicyDetailsList"];
        };
      };
    };
  };
  getApplicationRatePlans: {
    /**
     * Get all Application Rate Plans 
     * @description Retrieves all existing application rate plans.
     */
    responses: {
      /**
       * @description OK.
       * Policies returned
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["ApplicationRatePlanList"];
        };
      };
      406: components["responses"]["NotAcceptable"];
    };
  };
  addApplicationRatePlan: {
    /**
     * Add an Application Rate Plan 
     * @description This operation can be used to add a new application level rate plan.
     */
    /** @description Application level policy object that should to be added */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ApplicationRatePlan"];
      };
    };
    responses: {
      /**
       * @description Created.
       * Successful response with the newly created object as entity in the body.
       * Location header contains URL of newly created entity.
       */
      201: {
        headers: {
          /** @description Location of the newly created Policy object. */
          Location?: string;
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["ApplicationRatePlan"];
        };
      };
      400: components["responses"]["BadRequest"];
      415: components["responses"]["UnsupportedMediaType"];
    };
  };
  getApplicationRatePlanById: {
    /**
     * Get an Application Rate Plan 
     * @description Retrieves an application rate plan.
     */
    responses: {
      /**
       * @description OK.
       * Plan returned
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["ApplicationRatePlan"];
        };
      };
      404: components["responses"]["NotFound"];
      406: components["responses"]["NotAcceptable"];
    };
  };
  updateApplicationRatePlan: {
    /**
     * Update an Application Rate Plan 
     * @description Updates an existing application level rate plan. Upon a successful update, you will receive the updated application plan as the response.
     */
    /** @description Policy object that needs to be modified */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ApplicationRatePlan"];
      };
    };
    responses: {
      /**
       * @description OK.
       * Plan updated.
       */
      200: {
        headers: {
          /** @description The URL of the newly created resource. */
          Location?: string;
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["ApplicationRatePlan"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  removeApplicationRatePlan: {
    /**
     * Delete an Application Rate Plan 
     * @description Deletes an application level rate plan.
     */
    responses: {
      /**
       * @description OK.
       * Resource successfully deleted.
       */
      200: {
        content: {
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  getAllBusinessPlans: {
    /**
     * Get all Business Plans 
     * @description This operation can be used to retrieve all Business Plans.
     */
    responses: {
      /**
       * @description OK.
       * Plans returned
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["BusinessPlanList"];
        };
      };
      406: components["responses"]["NotAcceptable"];
    };
  };
  addBusinessPlan: {
    /**
     * Add a Business Plan 
     * @description This operation can be used to add a  Business Plan specifying the details of the plan in the payload.
     */
    /** @description Business Plan object that should to be added */
    requestBody: {
      content: {
        "application/json": components["schemas"]["BusinessPlan"];
      };
    };
    responses: {
      /**
       * @description Created.
       * Successful response with the newly created object as entity in the body.
       * Location header contains URL of newly created entity.
       */
      201: {
        headers: {
          /** @description Location of the newly created Plan object. */
          Location?: string;
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["BusinessPlan"];
        };
      };
      400: components["responses"]["BadRequest"];
      415: components["responses"]["UnsupportedMediaType"];
    };
  };
  getBusinessPlanById: {
    /**
     * Get a Business Plan 
     * @description This operation can be used to retrieves Business Plan by specifying the Id of the plan as a path parameter
     */
    responses: {
      /**
       * @description OK.
       * Plan returned
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["BusinessPlan"];
        };
      };
      404: components["responses"]["NotFound"];
      406: components["responses"]["NotAcceptable"];
    };
  };
  updateBusinessPlan: {
    /**
     * Update a Business Plan 
     * @description Updates an existing Business Plan.
     */
    /** @description Plan object that needs to be modified */
    requestBody: {
      content: {
        "application/json": components["schemas"]["BusinessPlan"];
      };
    };
    responses: {
      /**
       * @description OK.
       * Plan updated.
       */
      200: {
        headers: {
          /** @description The URL of the newly created resource. */
          Location?: string;
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["BusinessPlan"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  removeBusinessPlan: {
    /**
     * Delete a Business Plan 
     * @description This operation can be used to delete a business plan by specifying the Id of the plan as a path parameter.
     */
    responses: {
      /**
       * @description OK.
       * Resource successfully deleted.
       */
      200: {
        content: {
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  getAllAdvancedPolicy: {
    /**
     * Get all Advanced Throttling Policies 
     * @description Retrieves all existing advanced throttling policies.
     */
    responses: {
      /**
       * @description OK.
       * Policies returned
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["AdvancedThrottlePolicyList"];
        };
      };
      406: components["responses"]["NotAcceptable"];
    };
  };
  addAdvancedPolicy: {
    /**
     * Add an Advanced Throttling Policy 
     * @description Add a new advanced throttling policy.
     */
    /** @description Advanced level policy object that should to be added */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AdvancedThrottlePolicy"];
      };
    };
    responses: {
      /**
       * @description Created.
       * Successful response with the newly created object as entity in the body.
       * Location header contains URL of newly created entity.
       */
      201: {
        headers: {
          /** @description Location of the newly created Advanced Throttling Policy. */
          Location?: string;
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["AdvancedThrottlePolicy"];
        };
      };
      400: components["responses"]["BadRequest"];
      415: components["responses"]["UnsupportedMediaType"];
    };
  };
  getAdvancedPolicyById: {
    /**
     * Get an Advanced Throttling Policy 
     * @description Retrieves an advanced throttling policy.
     */
    responses: {
      /**
       * @description OK.
       * Policy returned
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["AdvancedThrottlePolicy"];
        };
      };
      404: components["responses"]["NotFound"];
      406: components["responses"]["NotAcceptable"];
    };
  };
  updateAdvancedPolicy: {
    /**
     * Update an Advanced Throttling Policy 
     * @description Updates an existing Advanced throttling policy.
     */
    /** @description Policy object that needs to be modified */
    requestBody: {
      content: {
        "application/json": components["schemas"]["AdvancedThrottlePolicy"];
      };
    };
    responses: {
      /**
       * @description OK.
       * Policy updated.
       */
      200: {
        headers: {
          /** @description The URL of the newly created resource. */
          Location?: string;
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["AdvancedThrottlePolicy"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  removeAdvancedPolicy: {
    /**
     * Delete an Advanced Throttling Policy 
     * @description Deletes an advanced throttling policy.
     */
    responses: {
      /**
       * @description OK.
       * Resource successfully deleted.
       */
      200: {
        content: {
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  exportThrottlingPolicy: {
    /**
     * Export a Throttling Policy 
     * @description This operation can be used to export the details of a particular Throttling Policy.
     */
    parameters?: {
        /** @description UUID of the ThrottlingPolicy */
        /** @description Throttling Policy Name */
        /** @description Type of the Throttling Policy */
        /** @description Format of output documents. Can be YAML or JSON. */
      query?: {
        policyId?: string;
        name?: string;
        type?: "sub" | "app" | "api" | "global";
        format?: "JSON" | "YAML";
      };
    };
    responses: {
      /**
       * @description OK.
       * Export Successful.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["ExportPolicy"];
        };
      };
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  importThrottlingPolicy: {
    /**
     * Import a Throttling Policy 
     * @description This operation can be used to import a Throttling Policy.
     */
    parameters?: {
        /** @description Update an existing throttling policy with the same name. */
      query?: {
        overwrite?: boolean;
      };
    };
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description Json File
           */
          file: string;
        };
      };
    };
    responses: {
      /**
       * @description Created.
       * Throttling Policy Imported Successfully.
       */
      200: never;
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      409: components["responses"]["Conflict"];
      500: components["responses"]["InternalServerError"];
    };
  };
  getAllDenyPolicies: {
    /**
     * Get all Deny Policies 
     * @description Retrieves all existing deny policies.
     */
    responses: {
      /**
       * @description OK.
       * Deny Policies returned
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["BlockingConditionList"];
        };
      };
      406: components["responses"]["NotAcceptable"];
    };
  };
  addDenyPolicy: {
    /**
     * Add a deny policy 
     * @description Adds a new deny policy
     */
    /** @description Blocking condition object that should to be added */
    requestBody: {
      content: {
        "application/json": components["schemas"]["BlockingCondition"];
      };
    };
    responses: {
      /**
       * @description Created.
       * Successful response with the newly created object as entity in the body.
       * Location header contains URL of newly created entity.
       */
      201: {
        headers: {
          /** @description Location of the newly created resource. */
          Location?: string;
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["BlockingCondition"];
        };
      };
      400: components["responses"]["BadRequest"];
      415: components["responses"]["UnsupportedMediaType"];
    };
  };
  getDenyPolicyById: {
    /**
     * Get a Deny Policy 
     * @description Retrieves a Deny policy providing the policy Id
     */
    responses: {
      /**
       * @description OK.
       * Condition returned
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["BlockingCondition"];
        };
      };
      404: components["responses"]["NotFound"];
      406: components["responses"]["NotAcceptable"];
    };
  };
  removeDenyPolicy: {
    /**
     * Delete a Deny Policy 
     * @description Deletes an existing deny policy
     */
    responses: {
      /**
       * @description OK.
       * Resource successfully deleted.
       */
      200: {
        content: {
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  updateDenyPolicy: {
    /**
     * Update a Deny Policy 
     * @description Update a deny policy by Id
     */
    /** @description Blocking condition with updated status */
    requestBody: {
      content: {
        "application/json": components["schemas"]["BlockingConditionStatus"];
      };
    };
    responses: {
      /**
       * @description OK.
       * Resource successfully updated.
       */
      200: {
        content: {
          "application/json": components["schemas"]["BlockingCondition"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  getApplicationsByUser: {
    /**
     * Retrieve/Search Applications
     *  
     * @description This operation can be used to retrieve list of applications owned by the given user, If no user
     * is provided, the applications owned by the user associated with the provided access token will be returned.
     */
    parameters?: {
        /** @description Application Name */
        /**
         * @description Tenant domain of the applications to get. This has to be specified only if it is required to get applications of
         * a tenant other than the requester's tenant. So, if not specified, the default will be set as the
         * requester's tenant domain. This cross tenant Application access is allowed only for super tenant admin
         * users **only at a migration process**.
         */
      query?: {
        name?: string;
        tenantDomain?: string;
        sortBy?: "name" | "owner";
        sortOrder?: "asc" | "desc";
      };
    };
    responses: {
      /**
       * @description OK.
       * Application list returned.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["ApplicationList"];
        };
      };
      400: components["responses"]["BadRequest"];
      406: components["responses"]["NotAcceptable"];
    };
  };
  getApplicationById: {
    /**
     * Get the details of an Application
     *  
     * @description This operation can be used to get the details of an application by specifying its id.
     */
    responses: {
      /**
       * @description OK.
       * Application details returned.
       */
      200: {
        content: {
          "application/json": components["schemas"]["Application"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
      406: components["responses"]["NotAcceptable"];
    };
  };
  removeApplication: {
    /**
     * Delete an Application
     *  
     * @description This operation can be used to delete an application by specifying its id.
     */
    responses: {
      /**
       * @description OK.
       * Resource successfully deleted.
       */
      200: {
        content: {
        };
      };
      /**
       * @description Accepted.
       * The request has been accepted.
       */
      202: {
        headers: {
          /** @description Location of the existing Application. */
          Location?: string;
        };
        content: {
          "application/json": components["schemas"]["WorkflowResponse"];
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  changeApplicationOwner: {
    /**
     * Change Application Owner 
     * @description This operation is used to change the owner of an Application.
     * In order to change the owner of an application, we need to pass the new application owner as a query parameter
     */
    parameters: {
      query: {
        owner: string;
      };
    };
    responses: {
      /**
       * @description OK.
       * Application owner changed successfully.
       */
      200: {
        content: {
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  getEnvironments: {
    /**
     * Get all registered Environments 
     * @description Get all Registered Environments
     */
    responses: {
      /**
       * @description OK.
       * Environments returned
       */
      200: {
        content: {
          "application/json": components["schemas"]["EnvironmentList"];
        };
      };
    };
  };
  addEnvironment: {
    /**
     * Add an Environment 
     * @description Add a new gateway environment
     */
    /** @description Environment object that should to be added */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Environment"];
      };
    };
    responses: {
      /**
       * @description Created.
       * Successful response with the newly created environment as entity in the body.
       */
      201: {
        content: {
          "application/json": components["schemas"]["Environment"];
        };
      };
      400: components["responses"]["BadRequest"];
    };
  };
  updateEnvironment: {
    /**
     * Update an Environment 
     * @description Update a gateway Environment by environment Id
     */
    /** @description Environment object with updated information */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Environment"];
      };
    };
    responses: {
      /**
       * @description OK.
       * Environment updated.
       */
      200: {
        content: {
          "application/json": components["schemas"]["Environment"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  removeEnvironment: {
    /**
     * Delete an Environment 
     * @description Delete a Environment by Environment Id
     */
    responses: {
      /**
       * @description OK.
       * Environment successfully deleted.
       */
      200: {
        content: {
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  getBotDetectionData: {
    /**
     * Get all Bot Detected Data
     *  
     * @description Get all bot detected data
     */
    responses: {
      /**
       * @description OK.
       * Bot detected data returned.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["BotDetectionDataList"];
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  publishMonetizationRecords: {
    /**
     * Publish Usage Records 
     * @description Publish usage records of monetized APIs
     */
    responses: {
      /** @description Usage records successfully published. */
      200: {
        content: {
          "application/json": components["schemas"]["PublishStatus"];
        };
      };
      /** @description Request is sucessfully accepted for processing. */
      202: {
        content: {
          "application/json": components["schemas"]["PublishStatus"];
        };
      };
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  getMonetizationUsagePublisherStatus: {
    /**
     * Get the Status of Monetization Usage Publisher 
     * @description Get the status of monetization usage publisher
     */
    responses: {
      /**
       * @description OK.
       * Status returned
       */
      200: {
        content: {
          "application/json": components["schemas"]["MonetizationUsagePublishInfo"];
        };
      };
    };
  };
  getAllPendingWorkflows: {
    /**
     * Retrieve All Pending Workflow Processes
     *  
     * @description This operation can be used to retrieve list of workflow pending processes.
     */
    parameters?: {
        /**
         * @description We need to show the values of each workflow process separately .for that we use workflow type.
         * Workflow type can be AM_APPLICATION_CREATION, AM_SUBSCRIPTION_CREATION,   AM_USER_SIGNUP, AM_APPLICATION_REGISTRATION_PRODUCTION, AM_APPLICATION_REGISTRATION_SANDBOX.
         */
      query?: {
        workflowType?: "AM_APPLICATION_CREATION" | "AM_SUBSCRIPTION_CREATION" | "AM_USER_SIGNUP" | "AM_APPLICATION_REGISTRATION_PRODUCTION" | "AM_APPLICATION_REGISTRATION_SANDBOX" | "AM_SUBSCRIPTION_DELETION" | "AM_APPLICATION_DELETION" | "AM_API_STATE" | "AM_API_PRODUCT_STATE";
      };
    };
    responses: {
      /**
       * @description OK.
       * Workflow pending process list returned.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["WorkflowList"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
      406: components["responses"]["NotAcceptable"];
    };
  };
  getWorkflowByExternalRef: {
    /**
     * Get Pending Workflow Details by External Workflow Reference
     *  
     * @description Using this operation, you can retrieve complete details of a pending workflow request that either belongs to application creation, application subscription, application registration, api state change, user self sign up.. You need to provide the External_Workflow_Reference of the workflow Request to retrieve it.
     */
    parameters: {
        /** @description from the external workflow reference we decide what is the the pending request that the are requesting. */
      path: {
        externalWorkflowRef: string;
      };
    };
    responses: {
      /**
       * @description OK.
       * Requested Workflow Pending is returned
       */
      200: {
        content: {
          "application/json": components["schemas"]["WorkflowInfo"];
        };
      };
      /**
       * @description Not Modified.
       * Empty body because the client has already the latest version of the requested resource.
       */
      304: {
        content: {
        };
      };
      404: components["responses"]["NotFound"];
      406: components["responses"]["NotAcceptable"];
    };
  };
  updateWorkflowStatus: {
    /**
     * Update Workflow Status 
     * @description This operation can be used to approve or reject a workflow task.
     */
    /** @description Workflow event that need to be updated */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Workflow"];
      };
    };
    responses: {
      /**
       * @description OK.
       * Workflow request information is returned.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["Workflow"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  getTenantInfoByUsername: {
    /**
     * Get Tenant Id of User
     *  
     * @description This operation is to get tenant id of the provided user
     */
    parameters: {
        /** @description The state represents the current state of the tenant. Supported states are [ active, inactive] */
      path: {
        username: string;
      };
    };
    responses: {
      /**
       * @description OK.
       * Tenant id of the user retrieved.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["TenantInfo"];
        };
      };
      404: components["responses"]["NotFound"];
      406: components["responses"]["NotAcceptable"];
    };
  };
  getCustomUrlInfoByTenantDomain: {
    /**
     * Get Custom URL Info of a Tenant Domain
     *  
     * @description This operation is to get custom-url information of the provided tenant-domain
     */
    parameters: {
        /** @description The tenant domain name. */
      path: {
        tenantDomain: string;
      };
    };
    responses: {
      /**
       * @description OK.
       * Custom url info of the tenant is retrieved.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["CustomUrlInfo"];
        };
      };
      404: components["responses"]["NotFound"];
      406: components["responses"]["NotAcceptable"];
    };
  };
  getAllCategories: {
    /**
     * Get all API Categories 
     * @description Get all API categories
     */
    responses: {
      /**
       * @description OK.
       * Categories returned
       */
      200: {
        content: {
          "application/json": components["schemas"]["APICategoryList"];
        };
      };
    };
  };
  addCategory: {
    /**
     * Add API Category 
     * @description Add a new API category
     */
    /** @description API Category object that should to be added */
    requestBody: {
      content: {
        "application/json": components["schemas"]["APICategory"];
      };
    };
    responses: {
      /**
       * @description Created.
       * Successful response with the newly created object as entity in the body.
       */
      201: {
        content: {
          "application/json": components["schemas"]["APICategory"];
        };
      };
      400: components["responses"]["BadRequest"];
    };
  };
  updateCategory: {
    /**
     * Update an API Category 
     * @description Update an API Category by category Id
     */
    /** @description API Category object with updated information */
    requestBody: {
      content: {
        "application/json": components["schemas"]["APICategory"];
      };
    };
    responses: {
      /**
       * @description OK.
       * Label updated.
       */
      200: {
        content: {
          "application/json": components["schemas"]["APICategory"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  removeCategory: {
    /**
     * Delete an API Category 
     * @description Delete an API Category by API Category Id
     */
    responses: {
      /**
       * @description OK.
       * API Category successfully deleted.
       */
      200: {
        content: {
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  getAdminSettings: {
    /**
     * Retrieve Admin Settings 
     * @description Retrieve admin settings
     */
    responses: {
      /**
       * @description OK.
       * Settings returned
       */
      200: {
        content: {
          "application/json": components["schemas"]["Settings"];
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  systemScopesScopeNameGet: {
    /**
     * Retrieve Scopes for a Particular User 
     * @description This operation will return the scope list of particular user
     * In order to get it, we need to pass the userId as a query parameter
     */
    parameters?: {
      query?: {
        username?: string;
      };
    };
    responses: {
      /**
       * @description OK.
       * Particular scope exists for the given user.
       */
      200: {
        content: {
          "application/json": components["schemas"]["ScopeSettings"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  systemScopesGet: {
    /**
     * Get Role Scope Mappings
     *  
     * @description This operation is used to get the list of role scope mapping from tenant-conf for the APK admin dashboard
     */
    responses: {
      /**
       * @description OK.
       * The list of role scope mappings are returned.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["ScopeList"];
        };
      };
      500: components["responses"]["InternalServerError"];
    };
  };
  updateRolesForScope: {
    /**
     * Update Roles For Scope
     *  
     * @description This operation is used to update the roles for all scopes
     */
    /** @description Scope list object with updated scope to role mappings */
    requestBody: {
      content: {
        "application/json": components["schemas"]["ScopeList"];
      };
    };
    responses: {
      /**
       * @description OK.
       * Successful response with the newly added roles.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["ScopeList"];
        };
      };
      400: components["responses"]["BadRequest"];
      500: components["responses"]["InternalServerError"];
    };
  };
  getRoleAliasMappings: {
    /**
     * Retrieve Role Alias Mappings 
     * @description This operation can be used to retrieve role alias mapping
     */
    responses: {
      /**
       * @description OK.
       * The list of role mappings are returned.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["RoleAliasList"];
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  addRoleAliasMapping: {
    /**
     * Add a New Role Alias 
     * @description This operation can be used to add a new role alias mapping for system scope roles
     */
    /** @description role-alias mapping */
    requestBody: {
      content: {
        "application/json": components["schemas"]["RoleAliasList"];
      };
    };
    responses: {
      /**
       * @description OK.
       * Role mapping alias returned
       */
      200: {
        content: {
          "application/json": components["schemas"]["RoleAliasList"];
        };
      };
      400: components["responses"]["BadRequest"];
      500: components["responses"]["InternalServerError"];
    };
  };
  validateSystemRole: {
    /**
     * Check Whether Given Role Name already Exist 
     * @description Using this operation, user can check a given role name exists or not.
     */
    responses: {
      /** @description OK. Requested role name exists. */
      200: {
        content: {
        };
      };
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  exportTenantTheme: {
    /**
     * Export a DevPortal Tenant Theme 
     * @description This operation can be used to export a DevPortal tenant theme as a zip file.
     */
    responses: {
      /**
       * @description OK.
       * Tenant Theme Exported Successfully.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/zip": string;
        };
      };
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  importTenantTheme: {
    /**
     * Import a DevPortal Tenant Theme 
     * @description This operation can be used to import a DevPortal tenant theme.
     */
    requestBody: {
      content: {
        "multipart/form-data": {
          /**
           * Format: binary 
           * @description Zip archive consisting of tenant theme configuration
           */
          file: string;
        };
      };
    };
    responses: {
      /**
       * @description Ok.
       * Tenant Theme Imported Successfully.
       */
      200: {
        content: {
        };
      };
      403: components["responses"]["Forbidden"];
      413: components["responses"]["PayloadTooLarge"];
      500: components["responses"]["InternalServerError"];
    };
  };
  exportTenantConfig: {
    /**
     * Export a tenant-Config. 
     * @description This operation can be used to export a tenant-config.json used in deployment.
     */
    responses: {
      /**
       * @description OK.
       * Tenant config Exported Successfully.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": string;
        };
      };
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  updateTenantConfig: {
    /**
     * Update a tenant-config. 
     * @description This operation can be used to update tenant-config.
     */
    /** @description tenant-config */
    requestBody: {
      content: {
        "application/json": string;
      };
    };
    responses: {
      /**
       * @description OK.
       * Role mapping alias returned
       */
      200: {
        content: {
          "application/json": string;
        };
      };
      403: components["responses"]["Forbidden"];
      413: components["responses"]["PayloadTooLarge"];
      500: components["responses"]["InternalServerError"];
    };
  };
  exportTenantConfigSchema: {
    /**
     * Export a tenant-Config-Schema. 
     * @description This operation can be used to export a tenant-config-schema.json used in deployment.
     */
    responses: {
      /**
       * @description OK.
       * Tenant config schema exported successfully.
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": string;
        };
      };
      403: components["responses"]["Forbidden"];
      404: components["responses"]["NotFound"];
      500: components["responses"]["InternalServerError"];
    };
  };
  getAllKeyManagers: {
    /**
     * Get all Key managers 
     * @description Get all Key managers
     */
    responses: {
      /**
       * @description OK.
       * KeyManagers returned
       */
      200: {
        content: {
          "application/json": components["schemas"]["KeyManagerList"];
        };
      };
    };
  };
  addNewKeyManager: {
    /**
     * Add a new API Key Manager 
     * @description Add a new API Key Manager
     */
    /** @description Key Manager object that should to be added */
    requestBody: {
      content: {
        "application/json": components["schemas"]["KeyManager"];
      };
    };
    responses: {
      /**
       * @description Created.
       * Successful response with the newly created object as entity in the body.
       */
      201: {
        content: {
          "application/json": components["schemas"]["KeyManager"];
        };
      };
      400: components["responses"]["BadRequest"];
    };
  };
  getKeyManagerConfiguration: {
    /**
     * Get a Key Manager Configuration 
     * @description Retrieve a single Key Manager Configuration. We should provide the Id of the KeyManager as a path parameter.
     */
    responses: {
      /**
       * @description OK.
       * KeyManager Configuration returned
       */
      200: {
        headers: {
          /** @description The content type of the body. */
          "Content-Type"?: string;
        };
        content: {
          "application/json": components["schemas"]["KeyManager"];
        };
      };
      404: components["responses"]["NotFound"];
      406: components["responses"]["NotAcceptable"];
    };
  };
  updateKeyManager: {
    /**
     * Update a Key Manager 
     * @description Update a Key Manager by keyManager ID
     */
    /** @description Key Manager object with updated information */
    requestBody: {
      content: {
        "application/json": components["schemas"]["KeyManager"];
      };
    };
    responses: {
      /**
       * @description OK.
       * Label updated.
       */
      200: {
        content: {
          "application/json": components["schemas"]["KeyManager"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  removeKeyManager: {
    /**
     * Delete a Key Manager 
     * @description Delete a Key Manager by keyManager id
     */
    responses: {
      /**
       * @description OK.
       * Key Manager successfully deleted.
       */
      200: {
        content: {
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  getWellKnownInfoKeyManager: {
    /**
     * Retrieve Well-known information from Key Manager Well-known Endpoint 
     * @description Retrieve well-known information from key manager's well-known endpoint
     */
    requestBody?: {
      content: {
        "multipart/form-data": {
          /** @description Well-Known Endpoint */
          url?: string;
          /**
           * @description Key Manager Type
           *  
           * @default false
           */
          type?: string;
        };
      };
    };
    responses: {
      /**
       * @description OK.
       * KeyManagers returned
       */
      200: {
        content: {
          "application/json": components["schemas"]["KeyManagerWellKnownResponse"];
        };
      };
    };
  };
  getAllOrganization: {
    /**
     * Get all Organization 
     * @description Get all Organization
     */
    responses: {
      /**
       * @description OK.
       * Organization returned
       */
      200: {
        content: {
          "application/json": components["schemas"]["OrganizationList"];
        };
      };
    };
  };
  addOrganization: {
    /**
     * Add Organization 
     * @description Add a new Organization
     */
    /** @description Organization object that should to be added */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Organization"];
      };
    };
    responses: {
      /**
       * @description Created.
       * Successful response with the newly created object as entity in the body.
       */
      201: {
        content: {
          "application/json": components["schemas"]["Organization"];
        };
      };
      400: components["responses"]["BadRequest"];
    };
  };
  getOrganizationById: {
    /**
     * Get the details of an Organization
     *  
     * @description This operation can be used to get the details of an Organization by specifying its id.
     */
    responses: {
      /**
       * @description OK.
       * Application details returned.
       */
      200: {
        content: {
          "application/json": components["schemas"]["Organization"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
      406: components["responses"]["NotAcceptable"];
    };
  };
  updateOrganization: {
    /**
     * Update an Organization 
     * @description Update an Organization by organization Id
     */
    /** @description Organization object with updated information */
    requestBody: {
      content: {
        "application/json": components["schemas"]["Organization"];
      };
    };
    responses: {
      /**
       * @description OK.
       * Label updated.
       */
      200: {
        content: {
          "application/json": components["schemas"]["Organization"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
  removeOrganization: {
    /**
     * Delete an Organization 
     * @description Delete an Organization by API Organization Id
     */
    responses: {
      /**
       * @description OK.
       * Organization successfully deleted.
       */
      200: {
        content: {
        };
      };
      404: components["responses"]["NotFound"];
    };
  };
  getOrganizationByClaimValue: {
    /**
     * Authenticate Organization info
     *  
     * @description This operation can be used to authenticate Organization by specifying its claimValue.
     */
    responses: {
      /**
       * @description OK.
       * Application details returned.
       */
      200: {
        content: {
          "application/json": components["schemas"]["Organization"];
        };
      };
      400: components["responses"]["BadRequest"];
      404: components["responses"]["NotFound"];
    };
  };
}
